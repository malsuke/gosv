// Package osv provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package osvapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for OsvCreditType.
const (
	OsvCreditTypeANALYST              OsvCreditType = "ANALYST"
	OsvCreditTypeCOORDINATOR          OsvCreditType = "COORDINATOR"
	OsvCreditTypeFINDER               OsvCreditType = "FINDER"
	OsvCreditTypeOTHER                OsvCreditType = "OTHER"
	OsvCreditTypeREMEDIATIONDEVELOPER OsvCreditType = "REMEDIATION_DEVELOPER"
	OsvCreditTypeREMEDIATIONREVIEWER  OsvCreditType = "REMEDIATION_REVIEWER"
	OsvCreditTypeREMEDIATIONVERIFIER  OsvCreditType = "REMEDIATION_VERIFIER"
	OsvCreditTypeREPORTER             OsvCreditType = "REPORTER"
	OsvCreditTypeSPONSOR              OsvCreditType = "SPONSOR"
	OsvCreditTypeTOOL                 OsvCreditType = "TOOL"
	OsvCreditTypeUNSPECIFIED          OsvCreditType = "UNSPECIFIED"
)

// Defines values for OsvRangeType.
const (
	OsvRangeTypeECOSYSTEM   OsvRangeType = "ECOSYSTEM"
	OsvRangeTypeGIT         OsvRangeType = "GIT"
	OsvRangeTypeSEMVER      OsvRangeType = "SEMVER"
	OsvRangeTypeUNSPECIFIED OsvRangeType = "UNSPECIFIED"
)

// Defines values for OsvReferenceType.
const (
	ADVISORY OsvReferenceType = "ADVISORY"
	ARTICLE  OsvReferenceType = "ARTICLE"
	EVIDENCE OsvReferenceType = "EVIDENCE"
	FIX      OsvReferenceType = "FIX"
	NONE     OsvReferenceType = "NONE"
	PACKAGE  OsvReferenceType = "PACKAGE"
	REPORT   OsvReferenceType = "REPORT"
	WEB      OsvReferenceType = "WEB"
)

// Defines values for OsvSeverityType.
const (
	OsvSeverityTypeCVSSV2      OsvSeverityType = "CVSS_V2"
	OsvSeverityTypeCVSSV3      OsvSeverityType = "CVSS_V3"
	OsvSeverityTypeCVSSV4      OsvSeverityType = "CVSS_V4"
	OsvSeverityTypeUNSPECIFIED OsvSeverityType = "UNSPECIFIED"
)

// Defines values for V1VersionRepositoryInformationRepoType.
const (
	V1VersionRepositoryInformationRepoTypeGIT         V1VersionRepositoryInformationRepoType = "GIT"
	V1VersionRepositoryInformationRepoTypeUNSPECIFIED V1VersionRepositoryInformationRepoType = "UNSPECIFIED"
)

// OsvAffected Affected versions and commits.
type OsvAffected struct {
	// DatabaseSpecific Optional. JSON object holding additional information about the
	// vulnerability as defined by the database for which the record applies.
	DatabaseSpecific *map[string]interface{} `json:"databaseSpecific,omitempty"`

	// EcosystemSpecific Optional. JSON object holding additional information about the
	// vulnerability as defined by the ecosystem for which the record applies.
	EcosystemSpecific *map[string]interface{} `json:"ecosystemSpecific,omitempty"`

	// Package Package information and version.
	Package *OsvPackage `json:"package,omitempty"`

	// Ranges Required. Range information.
	Ranges *[]OsvRange `json:"ranges,omitempty"`

	// Severity Optional. Severity of the vulnerability for this package.
	Severity *[]OsvSeverity `json:"severity,omitempty"`

	// Versions Optional. List of affected versions.
	Versions *[]string `json:"versions,omitempty"`
}

// OsvCredit defines model for osvCredit.
type OsvCredit struct {
	// Contact Contact methods (URLs).
	Contact *[]string `json:"contact,omitempty"`

	// Name The name to give credit to.
	Name *string        `json:"name,omitempty"`
	Type *OsvCreditType `json:"type,omitempty"`
}

// OsvCreditType defines model for osvCreditType.
type OsvCreditType string

// OsvEvent Version events.
type OsvEvent struct {
	// Fixed The version/commit that this vulnerability was fixed in.
	Fixed *string `json:"fixed,omitempty"`

	// Introduced The earliest version/commit where this vulnerability
	// was introduced in.
	Introduced *string `json:"introduced,omitempty"`

	// LastAffected The last affected version.
	LastAffected *string `json:"lastAffected,omitempty"`

	// Limit The limit to apply to the range.
	Limit *string `json:"limit,omitempty"`
}

// OsvPackage Package information and version.
type OsvPackage struct {
	// Ecosystem Required. The ecosystem for this package.
	// For the complete list of valid ecosystem names, see
	// <https://ossf.github.io/osv-schema/#affectedpackage-field>.
	Ecosystem *string `json:"ecosystem,omitempty"`

	// Name Required. Name of the package. Should match the name used in the package
	// ecosystem (e.g. the npm package name). For C/C++ projects integrated in
	// OSS-Fuzz, this is the name used for the integration.
	Name *string `json:"name,omitempty"`

	// Purl Optional. The package URL for this package.
	Purl *string `json:"purl,omitempty"`
}

// OsvRange Affected ranges.
type OsvRange struct {
	// Events Required. Version event information.
	Events *[]OsvEvent `json:"events,omitempty"`

	// Repo Required if type is GIT. The publicly accessible URL of the repo that can
	// be directly passed to clone commands.
	Repo *string `json:"repo,omitempty"`

	// Type Type of the version information.
	Type *OsvRangeType `json:"type,omitempty"`
}

// OsvRangeType Type of the version information.
type OsvRangeType string

// OsvReference Reference URL.
type OsvReference struct {
	Type *OsvReferenceType `json:"type,omitempty"`

	// Url Required. The URL.
	Url *string `json:"url,omitempty"`
}

// OsvReferenceType defines model for osvReferenceType.
type OsvReferenceType string

// OsvSeverity defines model for osvSeverity.
type OsvSeverity struct {
	// Score The quantitative score.
	Score *string `json:"score,omitempty"`

	// Type Type of the severity.
	Type *OsvSeverityType `json:"type,omitempty"`
}

// OsvSeverityType Type of the severity.
type OsvSeverityType string

// OsvVulnerability A vulnerability entry.
// The protobuf representation is *NOT* stable and only used for implementing
// the JSON based API.
type OsvVulnerability struct {
	// Affected Required. Affected commit ranges and versions.
	Affected *[]OsvAffected `json:"affected,omitempty"`

	// Aliases Optional. IDs for the same vulnerability in other databases.
	Aliases *[]string `json:"aliases,omitempty"`

	// Credits Optional. Credits for the vulnerability.
	Credits *[]OsvCredit `json:"credits,omitempty"`

	// DatabaseSpecific Optional. JSON object holding additional information about the
	// vulnerability as defined by the database for which the record applies.
	DatabaseSpecific *map[string]interface{} `json:"databaseSpecific,omitempty"`

	// Details Required. Any additional human readable details for the vulnerability.
	Details *string `json:"details,omitempty"`

	// Id The `id` field is a unique identifier for the vulnerability entry. It is a
	// string of the format `<DB>-<ENTRYID>`, where `DB` names the database and
	// `ENTRYID` is in the format used by the database. For example:
	// “OSV-2020-111”, “CVE-2021-3114”, or “GHSA-vp9c-fpxx-744v”.
	Id *string `json:"id,omitempty"`

	// Modified The RFC3339 timestamp indicating when this entry was last modified.
	Modified *time.Time `json:"modified,omitempty"`

	// Published The RFC3339 timestamp indicating when this entry was published.
	Published *time.Time `json:"published,omitempty"`

	// References Optional. URLs to more information/advisories (including the
	// scheme e.g "https://").
	References *[]OsvReference `json:"references,omitempty"`

	// Related Optional. List of IDs of closely related vulnerabilities, such as the same
	// problem in alternate ecosystems.
	Related *[]string `json:"related,omitempty"`

	// SchemaVersion The OSV schema version.
	SchemaVersion *string `json:"schemaVersion,omitempty"`

	// Severity Optional. Severity of the vulnerability.
	Severity *[]OsvSeverity `json:"severity,omitempty"`

	// Summary Required. One line human readable summary for the vulnerability. It is
	// recommended to keep this under 120 characters.
	Summary *string `json:"summary,omitempty"`

	// Withdrawn Optional. The RFC3339 timestamp indicating when this entry is considered to
	// be withdrawn.
	Withdrawn *time.Time `json:"withdrawn,omitempty"`
}

// ProtobufAny defines model for protobufAny.
type ProtobufAny struct {
	TypeUrl *string `json:"typeUrl,omitempty"`
	Value   *[]byte `json:"value,omitempty"`
}

// RpcStatus defines model for rpcStatus.
type RpcStatus struct {
	Code    *int32         `json:"code,omitempty"`
	Details *[]ProtobufAny `json:"details,omitempty"`
	Message *string        `json:"message,omitempty"`
}

// V1BatchQuery Batch query format.
type V1BatchQuery struct {
	// Queries The queries that form this batch query.
	Queries *[]V1Query `json:"queries,omitempty"`
}

// V1BatchVulnerabilityList Batched lists of Vulnerability entries.
type V1BatchVulnerabilityList struct {
	Results *[]V1VulnerabilityList `json:"results,omitempty"`
}

// V1FileHash Information about the files in the repository
// to identify the version.
type V1FileHash struct {
	// FilePath The file path inside the repository, relative to the repository root.
	FilePath *string `json:"filePath,omitempty"`
	Hash     *[]byte `json:"hash,omitempty"`
	HashType *string `json:"hashType,omitempty"`
}

// V1Query Query format.
type V1Query struct {
	// Commit The commit hash to query for. If specified, `version` should not be set.
	Commit *string `json:"commit,omitempty"`

	// Package Package information and version.
	Package   *OsvPackage `json:"package,omitempty"`
	PageToken *string     `json:"pageToken,omitempty"`

	// Version The version string to query for. A fuzzy match is done against upstream
	// versions. If specified, `commit` should not be set.
	Version *string `json:"version,omitempty"`
}

// V1VersionMatch Match information for the provided VersionQuery.
type V1VersionMatch struct {
	// Cpe23 CPE 2.3.
	Cpe23 *string `json:"cpe23,omitempty"`

	// OsvIdentifier Package information and version.
	OsvIdentifier *OsvPackage                     `json:"osvIdentifier,omitempty"`
	RepoInfo      *V1VersionRepositoryInformation `json:"repoInfo,omitempty"`

	// Score Score in the interval (0.0, 1.0] with 1.0 being a perfect match.
	Score *float64 `json:"score,omitempty"`
}

// V1VersionMatchList Result of DetmineVersion.
type V1VersionMatchList struct {
	Matches *[]V1VersionMatch `json:"matches,omitempty"`
}

// V1VersionQuery The version query.
type V1VersionQuery struct {
	FileHashes *[]V1FileHash `json:"fileHashes,omitempty"`

	// Name The name of the dependency. Can be empty.
	Name *string `json:"name,omitempty"`
}

// V1VersionRepositoryInformation defines model for v1VersionRepositoryInformation.
type V1VersionRepositoryInformation struct {
	// Address Source address of the repository.
	Address *string `json:"address,omitempty"`

	// Commit Commit hash.
	Commit  *[]byte                                 `json:"commit,omitempty"`
	Tag     *string                                 `json:"tag,omitempty"`
	Type    *V1VersionRepositoryInformationRepoType `json:"type,omitempty"`
	Version *string                                 `json:"version,omitempty"`
}

// V1VersionRepositoryInformationRepoType defines model for v1VersionRepositoryInformationRepoType.
type V1VersionRepositoryInformationRepoType string

// V1VulnerabilityList A list of Vulnerability entries.
type V1VulnerabilityList struct {
	NextPageToken *string             `json:"nextPageToken,omitempty"`
	Vulns         *[]OsvVulnerability `json:"vulns,omitempty"`
}

// OSVQueryAffectedJSONRequestBody defines body for OSVQueryAffected for application/json ContentType.
type OSVQueryAffectedJSONRequestBody = V1Query

// OSVQueryAffectedBatchJSONRequestBody defines body for OSVQueryAffectedBatch for application/json ContentType.
type OSVQueryAffectedBatchJSONRequestBody = V1BatchQuery

// OSVDetermineVersionJSONRequestBody defines body for OSVDetermineVersion for application/json ContentType.
type OSVDetermineVersionJSONRequestBody = V1VersionQuery

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// OSVQueryAffectedWithBody request with any body
	OSVQueryAffectedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OSVQueryAffected(ctx context.Context, body OSVQueryAffectedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OSVQueryAffectedBatchWithBody request with any body
	OSVQueryAffectedBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OSVQueryAffectedBatch(ctx context.Context, body OSVQueryAffectedBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OSVGetVulnById request
	OSVGetVulnById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OSVDetermineVersionWithBody request with any body
	OSVDetermineVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OSVDetermineVersion(ctx context.Context, body OSVDetermineVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) OSVQueryAffectedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVQueryAffectedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVQueryAffected(ctx context.Context, body OSVQueryAffectedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVQueryAffectedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVQueryAffectedBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVQueryAffectedBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVQueryAffectedBatch(ctx context.Context, body OSVQueryAffectedBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVQueryAffectedBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVGetVulnById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVGetVulnByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVDetermineVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVDetermineVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OSVDetermineVersion(ctx context.Context, body OSVDetermineVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOSVDetermineVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewOSVQueryAffectedRequest calls the generic OSVQueryAffected builder with application/json body
func NewOSVQueryAffectedRequest(server string, body OSVQueryAffectedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOSVQueryAffectedRequestWithBody(server, "application/json", bodyReader)
}

// NewOSVQueryAffectedRequestWithBody generates requests for OSVQueryAffected with any type of body
func NewOSVQueryAffectedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOSVQueryAffectedBatchRequest calls the generic OSVQueryAffectedBatch builder with application/json body
func NewOSVQueryAffectedBatchRequest(server string, body OSVQueryAffectedBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOSVQueryAffectedBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewOSVQueryAffectedBatchRequestWithBody generates requests for OSVQueryAffectedBatch with any type of body
func NewOSVQueryAffectedBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/querybatch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOSVGetVulnByIdRequest generates requests for OSVGetVulnById
func NewOSVGetVulnByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/vulns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOSVDetermineVersionRequest calls the generic OSVDetermineVersion builder with application/json body
func NewOSVDetermineVersionRequest(server string, body OSVDetermineVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOSVDetermineVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewOSVDetermineVersionRequestWithBody generates requests for OSVDetermineVersion with any type of body
func NewOSVDetermineVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1experimental/determineversion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// OSVQueryAffectedWithBodyWithResponse request with any body
	OSVQueryAffectedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVQueryAffectedResponse, error)

	OSVQueryAffectedWithResponse(ctx context.Context, body OSVQueryAffectedJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVQueryAffectedResponse, error)

	// OSVQueryAffectedBatchWithBodyWithResponse request with any body
	OSVQueryAffectedBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVQueryAffectedBatchResponse, error)

	OSVQueryAffectedBatchWithResponse(ctx context.Context, body OSVQueryAffectedBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVQueryAffectedBatchResponse, error)

	// OSVGetVulnByIdWithResponse request
	OSVGetVulnByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OSVGetVulnByIdResponse, error)

	// OSVDetermineVersionWithBodyWithResponse request with any body
	OSVDetermineVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVDetermineVersionResponse, error)

	OSVDetermineVersionWithResponse(ctx context.Context, body OSVDetermineVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVDetermineVersionResponse, error)
}

type OSVQueryAffectedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1VulnerabilityList
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r OSVQueryAffectedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OSVQueryAffectedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OSVQueryAffectedBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1BatchVulnerabilityList
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r OSVQueryAffectedBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OSVQueryAffectedBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OSVGetVulnByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OsvVulnerability
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r OSVGetVulnByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OSVGetVulnByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OSVDetermineVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1VersionMatchList
	JSONDefault  *RpcStatus
}

// Status returns HTTPResponse.Status
func (r OSVDetermineVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OSVDetermineVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// OSVQueryAffectedWithBodyWithResponse request with arbitrary body returning *OSVQueryAffectedResponse
func (c *ClientWithResponses) OSVQueryAffectedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVQueryAffectedResponse, error) {
	rsp, err := c.OSVQueryAffectedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVQueryAffectedResponse(rsp)
}

func (c *ClientWithResponses) OSVQueryAffectedWithResponse(ctx context.Context, body OSVQueryAffectedJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVQueryAffectedResponse, error) {
	rsp, err := c.OSVQueryAffected(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVQueryAffectedResponse(rsp)
}

// OSVQueryAffectedBatchWithBodyWithResponse request with arbitrary body returning *OSVQueryAffectedBatchResponse
func (c *ClientWithResponses) OSVQueryAffectedBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVQueryAffectedBatchResponse, error) {
	rsp, err := c.OSVQueryAffectedBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVQueryAffectedBatchResponse(rsp)
}

func (c *ClientWithResponses) OSVQueryAffectedBatchWithResponse(ctx context.Context, body OSVQueryAffectedBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVQueryAffectedBatchResponse, error) {
	rsp, err := c.OSVQueryAffectedBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVQueryAffectedBatchResponse(rsp)
}

// OSVGetVulnByIdWithResponse request returning *OSVGetVulnByIdResponse
func (c *ClientWithResponses) OSVGetVulnByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OSVGetVulnByIdResponse, error) {
	rsp, err := c.OSVGetVulnById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVGetVulnByIdResponse(rsp)
}

// OSVDetermineVersionWithBodyWithResponse request with arbitrary body returning *OSVDetermineVersionResponse
func (c *ClientWithResponses) OSVDetermineVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OSVDetermineVersionResponse, error) {
	rsp, err := c.OSVDetermineVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVDetermineVersionResponse(rsp)
}

func (c *ClientWithResponses) OSVDetermineVersionWithResponse(ctx context.Context, body OSVDetermineVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*OSVDetermineVersionResponse, error) {
	rsp, err := c.OSVDetermineVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOSVDetermineVersionResponse(rsp)
}

// ParseOSVQueryAffectedResponse parses an HTTP response from a OSVQueryAffectedWithResponse call
func ParseOSVQueryAffectedResponse(rsp *http.Response) (*OSVQueryAffectedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OSVQueryAffectedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1VulnerabilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOSVQueryAffectedBatchResponse parses an HTTP response from a OSVQueryAffectedBatchWithResponse call
func ParseOSVQueryAffectedBatchResponse(rsp *http.Response) (*OSVQueryAffectedBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OSVQueryAffectedBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1BatchVulnerabilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOSVGetVulnByIdResponse parses an HTTP response from a OSVGetVulnByIdWithResponse call
func ParseOSVGetVulnByIdResponse(rsp *http.Response) (*OSVGetVulnByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OSVGetVulnByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OsvVulnerability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOSVDetermineVersionResponse parses an HTTP response from a OSVDetermineVersionWithResponse call
func ParseOSVDetermineVersionResponse(rsp *http.Response) (*OSVDetermineVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OSVDetermineVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1VersionMatchList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
