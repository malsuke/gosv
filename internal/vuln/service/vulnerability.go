package service

import (
	"context"
	"fmt"
	"time"

	"github.com/google/go-github/v77/github"
	ghapi "github.com/malsuke/govs/internal/github/api"
	"github.com/malsuke/govs/internal/github/domain"
	osvapi "github.com/malsuke/govs/internal/osv/api"
	osvdomain "github.com/malsuke/govs/internal/osv/domain"
	vulndomain "github.com/malsuke/govs/internal/vuln/domain"
)

// FetchVulnerabilitiesByRepository は GitHub リポジトリ単位で OSV 脆弱性を取得し Vulnerability ドメインへ変換する。
func FetchVulnerabilitiesByRepository(ctx context.Context, owner, name string) ([]vulndomain.Vulnerability, error) {
	if err := domain.ValidateRepository(owner, name); err != nil {
		return nil, err
	}

	raw, err := osvapi.ListCVEVulnerabilitiesByRepository(ctx, owner, name)
	if err != nil {
		return nil, err
	}

	result := make([]vulndomain.Vulnerability, 0, len(raw))
	for _, v := range raw {
		cveID := osvapi.ExtractCVEFromVulnerability(&v)
		if cveID == "" {
			continue
		}
		result = append(result, vulndomain.Vulnerability{
			ID:              cveID,
			RepositoryOwner: owner,
			RepositoryName:  name,
			Details:         v,
		})
	}

	return result, nil
}

// ListCVEIDsByRepository は FetchVulnerabilitiesByRepository のラッパーとして CVE ID 一覧を返却する。
func ListCVEIDsByRepository(ctx context.Context, owner, name string) ([]string, error) {
	vulns, err := FetchVulnerabilitiesByRepository(ctx, owner, name)
	if err != nil {
		return nil, err
	}

	result := make([]string, 0, len(vulns))
	for _, v := range vulns {
		result = append(result, v.ID)
	}
	return result, nil
}

// SuspectedPullRequests holds contextual information about potentially introducing PRs.
type SuspectedPullRequests struct {
	Vulnerability            vulndomain.Vulnerability
	AffectedVersions         []string
	EarliestAffectedVersion  string
	PreviousRelease          *github.RepositoryRelease
	TargetRelease            *github.RepositoryRelease
	MergedPullRequests       []*github.Issue
	InvestigationWindowStart time.Time
	InvestigationWindowEnd   time.Time
}

// FindSuspectedPullRequestsByVersions はバージョン情報を元に、導入が疑われる PR を検索する。
func FindSuspectedPullRequestsByVersions(
	ctx context.Context,
	client *ghapi.Client,
	osvVuln *osvapi.OsvVulnerability,
	releases []*github.RepositoryRelease,
	cveID string,
) (*SuspectedPullRequests, error) {
	if len(releases) == 0 {
		return nil, fmt.Errorf("releases must not be empty")
	}

	owner, name, err := osvdomain.ExtractRepository(osvVuln)
	if err != nil {
		return nil, err
	}
	if err := domain.ValidateRepository(owner, name); err != nil {
		return nil, err
	}
	if client.Owner != owner || client.Name != name {
		return nil, fmt.Errorf("github client repository mismatch: expected %s/%s, got %s/%s", owner, name, client.Owner, client.Name)
	}

	versions := osvdomain.CollectReleaseVersions(osvVuln)
	if len(versions) == 0 {
		panic(fmt.Sprintf("affected versions not found in vulnerability: cveID=%s", cveID))
	}

	affectedReleases := make([]*github.RepositoryRelease, 0)
	unmatchedVersions := make([]string, 0)
	for _, version := range versions {
		release := domain.FindReleaseByVersion(releases, version)
		if release != nil {
			affectedReleases = append(affectedReleases, release)
		} else {
			unmatchedVersions = append(unmatchedVersions, version)
		}
	}

	if len(affectedReleases) == 0 {
		// デバッグ用: 最初の10個のリリースのタグ名を表示
		releaseTags := make([]string, 0)
		for i, r := range releases {
			if i >= 10 {
				break
			}
			if r != nil {
				releaseTags = append(releaseTags, r.GetTagName())
			}
		}
		panic(fmt.Sprintf("no releases found for affected versions in repository %s/%s: versions=%v, unmatchedVersions=%v, available releases=%d, sample release tags=%v", owner, name, versions, unmatchedVersions, len(releases), releaseTags))
	}

	// 影響を受けるリリースの中で最も古いものを探す（ソートは使わない）
	var targetRelease *github.RepositoryRelease
	var targetTime time.Time
	for _, release := range affectedReleases {
		if release == nil {
			continue
		}
		releaseTime, ok := domain.ReleaseTime(release)
		if !ok {
			continue
		}
		if targetRelease == nil || releaseTime.Before(targetTime) {
			targetRelease = release
			targetTime = releaseTime
		}
	}
	if targetRelease == nil {
		panic(fmt.Sprintf("no valid release found in affected releases: affectedReleases=%d", len(affectedReleases)))
	}

	// targetReleaseより前の時刻を持つリリースの中で、最もtargetReleaseに近い時刻のものを探す
	var previousRelease *github.RepositoryRelease
	var previousTime time.Time
	for _, release := range releases {
		if release == nil {
			continue
		}
		releaseTime, ok := domain.ReleaseTime(release)
		if !ok {
			continue
		}
		// targetReleaseより前の時刻で、かつ最も近い時刻のものを選択
		if releaseTime.Before(targetTime) {
			if previousRelease == nil || releaseTime.After(previousTime) {
				previousRelease = release
				previousTime = releaseTime
			}
		}
	}

	var start time.Time
	if previousRelease == nil {
		// 前のリリースが見つからない場合、リポジトリの作成日時を使用
		repo, err := client.GetRepository(ctx)
		if err != nil {
			panic(fmt.Sprintf("failed to get repository to determine start time: %v", err))
		}
		if repo.CreatedAt == nil || repo.CreatedAt.IsZero() {
			panic(fmt.Sprintf("repository creation time is not available: targetRelease=%s", targetRelease.GetTagName()))
		}
		start = repo.CreatedAt.Time
	} else {
		var ok bool
		start, ok = domain.ReleaseTime(previousRelease)
		if !ok {
			panic(fmt.Sprintf("previous release lacks timestamp information: previousRelease=%s", previousRelease.GetTagName()))
		}
	}
	end, ok := domain.ReleaseTime(targetRelease)
	if !ok {
		panic(fmt.Sprintf("target release lacks timestamp information: targetRelease=%s", targetRelease.GetTagName()))
	}
	if !end.After(start) {
		prevReleaseTag := "repository creation"
		if previousRelease != nil {
			prevReleaseTag = previousRelease.GetTagName()
		}
		panic(fmt.Sprintf("invalid release ordering: start=%s, end=%s, previousRelease=%s, targetRelease=%s", start, end, prevReleaseTag, targetRelease.GetTagName()))
	}

	issues, err := client.SearchMergedPullRequests(ctx, start, end)
	if err != nil {
		panic(fmt.Sprintf("failed to search merged pull requests: start=%s, end=%s, error=%v", start, end, err))
	}

	result := &SuspectedPullRequests{
		Vulnerability: vulndomain.Vulnerability{
			ID:              cveID,
			RepositoryOwner: owner,
			RepositoryName:  name,
			Details:         *osvVuln,
		},
		AffectedVersions:         versions,
		EarliestAffectedVersion:  targetRelease.GetTagName(),
		PreviousRelease:          previousRelease,
		TargetRelease:            targetRelease,
		MergedPullRequests:       issues,
		InvestigationWindowStart: start,
		InvestigationWindowEnd:   end,
	}

	return result, nil
}

// FindSuspectedPullRequestsByCVE は CVE ID から脆弱性を取得し、FindSuspectedPullRequestsByVersions を呼び出す。
// 後方互換性のため残されていますが、既に取得済みの情報がある場合は FindSuspectedPullRequestsByVersions を直接使用してください。
func FindSuspectedPullRequestsByCVE(ctx context.Context, client *ghapi.Client, cveID string) (*SuspectedPullRequests, error) {
	if cveID == "" {
		return nil, fmt.Errorf("cve id must not be empty")
	}

	osvVuln, err := osvapi.GetVulnerabilityByCVE(ctx, cveID)
	if err != nil {
		return nil, err
	}

	releases, err := client.ListAllStableReleases(ctx)
	if err != nil {
		return nil, err
	}
	if len(releases) == 0 {
		owner, name, _ := osvdomain.ExtractRepository(osvVuln)
		return nil, fmt.Errorf("no releases found for repository %s/%s", owner, name)
	}

	return FindSuspectedPullRequestsByVersions(ctx, client, osvVuln, releases, cveID)
}
