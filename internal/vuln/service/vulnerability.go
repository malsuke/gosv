package service

import (
	"context"
	"fmt"
	"time"

	"github.com/google/go-github/v77/github"
	ghapi "github.com/malsuke/govs/internal/github/api"
	gh "github.com/malsuke/govs/internal/github/domain"
	osvapi "github.com/malsuke/govs/internal/osv/api"
	osvdomain "github.com/malsuke/govs/internal/osv/domain"
	vulndomain "github.com/malsuke/govs/internal/vuln/domain"
)

// FetchVulnerabilitiesByRepository は GitHub リポジトリ単位で OSV 脆弱性を取得し Vulnerability ドメインへ変換する。
func FetchVulnerabilitiesByRepository(ctx context.Context, repo gh.Repository) ([]vulndomain.Vulnerability, error) {
	if ctx == nil {
		return nil, fmt.Errorf("context must not be nil")
	}
	if err := repo.Validate(); err != nil {
		return nil, err
	}

	raw, err := osvapi.ListCVEVulnerabilitiesByRepository(ctx, repo)
	if err != nil {
		return nil, err
	}

	result := make([]vulndomain.Vulnerability, 0, len(raw))
	for _, v := range raw {
		cveID := osvapi.ExtractCVEFromVulnerability(&v)
		if cveID == "" {
			continue
		}
		result = append(result, vulndomain.Vulnerability{
			ID:         cveID,
			Repository: repo,
			Details:    v,
		})
	}

	return result, nil
}

// ListCVEIDsByRepository は FetchVulnerabilitiesByRepository のラッパーとして CVE ID 一覧を返却する。
func ListCVEIDsByRepository(ctx context.Context, repo gh.Repository) ([]string, error) {
	vulns, err := FetchVulnerabilitiesByRepository(ctx, repo)
	if err != nil {
		return nil, err
	}

	result := make([]string, 0, len(vulns))
	for _, v := range vulns {
		result = append(result, v.ID)
	}
	return result, nil
}

// SuspectedPullRequests holds contextual information about potentially introducing PRs.
type SuspectedPullRequests struct {
	Vulnerability            vulndomain.Vulnerability
	AffectedVersions         []string
	EarliestAffectedVersion  string
	PreviousRelease          *github.RepositoryRelease
	TargetRelease            *github.RepositoryRelease
	MergedPullRequests       []*github.Issue
	InvestigationWindowStart time.Time
	InvestigationWindowEnd   time.Time
}

// FindSuspectedPullRequestsByCVE 推定された影響バージョンを元に、導入が疑われる PR を検索する。
func FindSuspectedPullRequestsByCVE(ctx context.Context, client *ghapi.Client, cveID string) (*SuspectedPullRequests, error) {
	if ctx == nil {
		return nil, fmt.Errorf("context must not be nil")
	}
	if client == nil {
		return nil, fmt.Errorf("github client must not be nil")
	}
	if cveID == "" {
		return nil, fmt.Errorf("cve id must not be empty")
	}

	osvVuln, err := osvapi.GetVulnerabilityByCVE(ctx, cveID)
	if err != nil {
		return nil, err
	}

	repo, err := osvdomain.ExtractRepository(osvVuln)
	if err != nil {
		return nil, err
	}
	if err := repo.Validate(); err != nil {
		return nil, err
	}

	versions := osvdomain.CollectReleaseVersions(osvVuln)
	if len(versions) == 0 {
		return nil, fmt.Errorf("affected versions not found in vulnerability %s", cveID)
	}
	targetVersion := versions[0]

	releases, err := client.ListReleases(ctx, &repo, ghapi.ReleaseListOptions{
		ExcludePreRelease: true,
		ListOptions:       github.ListOptions{PerPage: 100},
	})
	if err != nil {
		return nil, err
	}
	if len(releases) == 0 {
		return nil, fmt.Errorf("no releases found for repository %s/%s", repo.Owner, repo.Name)
	}

	targetRelease := gh.FindReleaseByVersion(releases, targetVersion)
	if targetRelease == nil {
		return nil, fmt.Errorf("release for version %s not found in repository %s/%s", targetVersion, repo.Owner, repo.Name)
	}

	sorted := gh.SortReleasesByTime(releases)
	targetIdx := indexOfRelease(sorted, targetRelease)
	if targetIdx <= 0 {
		return nil, fmt.Errorf("previous release not found prior to version %s", targetVersion)
	}

	previousRelease := sorted[targetIdx-1]
	start, ok := gh.ReleaseTime(previousRelease)
	if !ok {
		return nil, fmt.Errorf("previous release lacks timestamp information")
	}
	end, ok := gh.ReleaseTime(targetRelease)
	if !ok {
		return nil, fmt.Errorf("target release lacks timestamp information")
	}
	if !end.After(start) {
		return nil, fmt.Errorf("invalid release ordering: start %s, end %s", start, end)
	}

	issues, err := client.SearchMergedPullRequests(ctx, repo, start, end)
	if err != nil {
		return nil, err
	}

	result := &SuspectedPullRequests{
		Vulnerability: vulndomain.Vulnerability{
			ID:         cveID,
			Repository: repo,
		},
		AffectedVersions:         versions,
		EarliestAffectedVersion:  targetVersion,
		PreviousRelease:          previousRelease,
		TargetRelease:            targetRelease,
		MergedPullRequests:       issues,
		InvestigationWindowStart: start,
		InvestigationWindowEnd:   end,
	}

	if osvVuln != nil {
		result.Vulnerability.Details = *osvVuln
	}

	return result, nil
}

func indexOfRelease(releases []*github.RepositoryRelease, target *github.RepositoryRelease) int {
	for idx, release := range releases {
		if release == target {
			return idx
		}
	}
	return -1
}
