package service

import (
	"context"
	"fmt"
	"time"

	"github.com/google/go-github/v77/github"
	ghapi "github.com/malsuke/govs/internal/github/api"
	"github.com/malsuke/govs/internal/github/domain"
	osvapi "github.com/malsuke/govs/internal/osv/api"
	osvdomain "github.com/malsuke/govs/internal/osv/domain"
	vulndomain "github.com/malsuke/govs/internal/vuln/domain"
)

// FetchVulnerabilitiesByRepository は GitHub リポジトリ単位で OSV 脆弱性を取得し Vulnerability ドメインへ変換する。
func FetchVulnerabilitiesByRepository(ctx context.Context, owner, name string) ([]vulndomain.Vulnerability, error) {
	if ctx == nil {
		return nil, fmt.Errorf("context must not be nil")
	}
	if err := domain.ValidateRepository(owner, name); err != nil {
		return nil, err
	}

	raw, err := osvapi.ListCVEVulnerabilitiesByRepository(ctx, owner, name)
	if err != nil {
		return nil, err
	}

	result := make([]vulndomain.Vulnerability, 0, len(raw))
	for _, v := range raw {
		cveID := osvapi.ExtractCVEFromVulnerability(&v)
		if cveID == "" {
			continue
		}
		result = append(result, vulndomain.Vulnerability{
			ID:              cveID,
			RepositoryOwner: owner,
			RepositoryName:  name,
			Details:         v,
		})
	}

	return result, nil
}

// ListCVEIDsByRepository は FetchVulnerabilitiesByRepository のラッパーとして CVE ID 一覧を返却する。
func ListCVEIDsByRepository(ctx context.Context, owner, name string) ([]string, error) {
	vulns, err := FetchVulnerabilitiesByRepository(ctx, owner, name)
	if err != nil {
		return nil, err
	}

	result := make([]string, 0, len(vulns))
	for _, v := range vulns {
		result = append(result, v.ID)
	}
	return result, nil
}

// SuspectedPullRequests holds contextual information about potentially introducing PRs.
type SuspectedPullRequests struct {
	Vulnerability            vulndomain.Vulnerability
	AffectedVersions         []string
	EarliestAffectedVersion  string
	PreviousRelease          *github.RepositoryRelease
	TargetRelease            *github.RepositoryRelease
	MergedPullRequests       []*github.Issue
	InvestigationWindowStart time.Time
	InvestigationWindowEnd   time.Time
}

// FindSuspectedPullRequestsByVersions はバージョン情報を元に、導入が疑われる PR を検索する。
func FindSuspectedPullRequestsByVersions(
	ctx context.Context,
	client *ghapi.Client,
	osvVuln *osvapi.OsvVulnerability,
	releases []*github.RepositoryRelease,
	cveID string,
) (*SuspectedPullRequests, error) {
	if ctx == nil {
		return nil, fmt.Errorf("context must not be nil")
	}
	if client == nil {
		return nil, fmt.Errorf("github client must not be nil")
	}
	if osvVuln == nil {
		return nil, fmt.Errorf("osv vulnerability must not be nil")
	}
	if len(releases) == 0 {
		return nil, fmt.Errorf("releases must not be empty")
	}

	owner, name, err := osvdomain.ExtractRepository(osvVuln)
	if err != nil {
		return nil, err
	}
	if err := domain.ValidateRepository(owner, name); err != nil {
		return nil, err
	}
	if client.Owner != owner || client.Name != name {
		return nil, fmt.Errorf("github client repository mismatch: expected %s/%s, got %s/%s", owner, name, client.Owner, client.Name)
	}

	versions := osvdomain.CollectReleaseVersions(osvVuln)
	if len(versions) == 0 {
		return nil, fmt.Errorf("affected versions not found in vulnerability")
	}
	targetVersion := versions[0]

	targetRelease := domain.FindReleaseByVersion(releases, targetVersion)
	if targetRelease == nil {
		return nil, fmt.Errorf("release for version %s not found in repository %s/%s", targetVersion, owner, name)
	}

	sorted := domain.SortReleasesByTime(releases)
	targetIdx := indexOfRelease(sorted, targetRelease)
	if targetIdx <= 0 {
		return nil, fmt.Errorf("previous release not found prior to version %s", targetVersion)
	}

	previousRelease := sorted[targetIdx-1]
	start, ok := domain.ReleaseTime(previousRelease)
	if !ok {
		return nil, fmt.Errorf("previous release lacks timestamp information")
	}
	end, ok := domain.ReleaseTime(targetRelease)
	if !ok {
		return nil, fmt.Errorf("target release lacks timestamp information")
	}
	if !end.After(start) {
		return nil, fmt.Errorf("invalid release ordering: start %s, end %s", start, end)
	}

	issues, err := client.SearchMergedPullRequests(ctx, start, end)
	if err != nil {
		return nil, err
	}

	result := &SuspectedPullRequests{
		Vulnerability: vulndomain.Vulnerability{
			ID:              cveID,
			RepositoryOwner: owner,
			RepositoryName:  name,
			Details:         *osvVuln,
		},
		AffectedVersions:         versions,
		EarliestAffectedVersion:  targetVersion,
		PreviousRelease:          previousRelease,
		TargetRelease:            targetRelease,
		MergedPullRequests:       issues,
		InvestigationWindowStart: start,
		InvestigationWindowEnd:   end,
	}

	return result, nil
}

// FindSuspectedPullRequestsByCVE は CVE ID から脆弱性を取得し、FindSuspectedPullRequestsByVersions を呼び出す。
// 後方互換性のため残されていますが、既に取得済みの情報がある場合は FindSuspectedPullRequestsByVersions を直接使用してください。
func FindSuspectedPullRequestsByCVE(ctx context.Context, client *ghapi.Client, cveID string) (*SuspectedPullRequests, error) {
	if cveID == "" {
		return nil, fmt.Errorf("cve id must not be empty")
	}

	osvVuln, err := osvapi.GetVulnerabilityByCVE(ctx, cveID)
	if err != nil {
		return nil, err
	}

	releases, err := client.ListReleases(ctx, ghapi.ReleaseListOptions{
		ExcludePreRelease: true,
		ListOptions:       github.ListOptions{PerPage: 100},
	})
	if err != nil {
		return nil, err
	}
	if len(releases) == 0 {
		owner, name, _ := osvdomain.ExtractRepository(osvVuln)
		return nil, fmt.Errorf("no releases found for repository %s/%s", owner, name)
	}

	return FindSuspectedPullRequestsByVersions(ctx, client, osvVuln, releases, cveID)
}

func indexOfRelease(releases []*github.RepositoryRelease, target *github.RepositoryRelease) int {
	for idx, release := range releases {
		if release == target {
			return idx
		}
	}
	return -1
}
